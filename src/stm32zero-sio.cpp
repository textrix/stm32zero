/**
 * STM32ZERO Serial I/O Module Implementation
 */

#include "main.h"
#include "stm32zero.hpp"
#include "stm32zero-sio.hpp"
#include "stm32zero-uart.hpp"

//=============================================================================
// Configuration
//=============================================================================

#if __has_include("stm32zero-conf.h")
#include "stm32zero-conf.h"
#endif

#ifndef STM32ZERO_SIO_UART
#error "STM32ZERO_SIO_UART must be defined in stm32zero-conf.h"
#endif

#ifndef STM32ZERO_SIO_RX_SIZE
#define STM32ZERO_SIO_RX_SIZE		256
#endif

#ifndef STM32ZERO_SIO_TX_SIZE
#define STM32ZERO_SIO_TX_SIZE		4096
#endif

#ifndef STM32ZERO_SIO_DMA_SIZE
#define STM32ZERO_SIO_DMA_SIZE		64
#endif

// UART handle declaration (generated by STM32CubeMX)
extern UART_HandleTypeDef STM32ZERO_SIO_UART;

//=============================================================================
// Uart instance
//=============================================================================

STM32ZERO_DEFINE_UART(sio_uart_, STM32ZERO_SIO_UART, STM32ZERO_SIO_TX_SIZE, STM32ZERO_SIO_RX_SIZE, STM32ZERO_SIO_DMA_SIZE);

static bool initialized_ = false;

//=============================================================================
// Public API
//=============================================================================

namespace stm32zero {
namespace sio {

void init()
{
	if (initialized_) {
		return;
	}
	initialized_ = true;

	STM32ZERO_INIT_UART(sio_uart_, STM32ZERO_SIO_UART);
}

//-----------------------------------------------------------------------------
// Write (TX)
//-----------------------------------------------------------------------------

int write(const void* data, size_t len)
{
	return sio_uart_.write(data, len);
}

int vwritef(char* buf, size_t size, const char* fmt, va_list args)
{
	return sio_uart_.vwritef(buf, size, fmt, args);
}

int writef(char* buf, size_t size, const char* fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	int len = vwritef(buf, size, fmt, args);
	va_end(args);
	return len;
}

bool flush()
{
	return sio_uart_.flush();
}

bool is_tx_busy()
{
	return sio_uart_.is_tx_busy();
}

uint16_t tx_pending()
{
	return sio_uart_.pending();
}

uint16_t tx_water_mark()
{
	return sio_uart_.tx_water_mark();
}

//-----------------------------------------------------------------------------
// Read (RX)
//-----------------------------------------------------------------------------

int read(void* data, size_t len)
{
	return sio_uart_.read(data, len);
}

int read(void* data, size_t len, uint32_t timeout_ms)
{
	return sio_uart_.read(data, len, timeout_ms);
}

int readln(char* buf, size_t len, uint32_t timeout_ms)
{
	return sio_uart_.readln(buf, len, timeout_ms);
}

bool wait(uint32_t timeout_ms)
{
	return sio_uart_.wait(timeout_ms);
}

size_t available()
{
	return sio_uart_.available();
}

bool is_empty()
{
	return sio_uart_.is_empty();
}

uint16_t rx_water_mark()
{
	return sio_uart_.rx_water_mark();
}

#if defined(STM32ZERO_RTOS_FREERTOS) && (STM32ZERO_RTOS_FREERTOS == 1)
SemaphoreHandle_t semaphore()
{
	return sio_uart_.semaphore();
}
#endif

} // namespace sio
} // namespace stm32zero

//=============================================================================
// printf/scanf support (enabled by default)
//=============================================================================

#if !defined(STM32ZERO_SIO_NO_STDIO)

extern "C" int _write(int file, char* ptr, int len)
{
	(void)file;
	stm32zero::sio::write(ptr, static_cast<size_t>(len));
	return len;
}

extern "C" int _read(int file, char* ptr, int len)
{
	(void)file;

	// Block until at least 1 byte is available
#if defined(STM32ZERO_RTOS_FREERTOS) && (STM32ZERO_RTOS_FREERTOS == 1)
	while (stm32zero::sio::is_empty()) {
		stm32zero::sio::wait(portMAX_DELAY);
	}
#else
	stm32zero::wait_until([]{ return !stm32zero::sio::is_empty(); }, UINT32_MAX);
#endif
	return stm32zero::sio::read(ptr, static_cast<size_t>(len));
}

#endif // !STM32ZERO_SIO_NO_STDIO
