/**
 * STM32ZERO Serial I/O Module Implementation
 */

#include "main.h"
#include "stm32zero.hpp"
#include "stm32zero-sio.hpp"
#include "stm32zero-uart.hpp"

//=============================================================================
// Configuration
//=============================================================================

#if __has_include("stm32zero-conf.h")
#include "stm32zero-conf.h"
#endif

#ifndef STM32ZERO_SIO_UART
#error "STM32ZERO_SIO_UART must be defined in stm32zero-conf.h"
#endif

#ifndef STM32ZERO_SIO_RX_SIZE
#define STM32ZERO_SIO_RX_SIZE		256
#endif

#ifndef STM32ZERO_SIO_TX_SIZE
#define STM32ZERO_SIO_TX_SIZE		4096
#endif

#ifndef STM32ZERO_SIO_DMA_SIZE
#define STM32ZERO_SIO_DMA_SIZE		64
#endif

// UART handle declaration (generated by STM32CubeMX)
extern UART_HandleTypeDef STM32ZERO_SIO_UART;

//=============================================================================
// Uart instance
//=============================================================================

STM32ZERO_DEFINE_UART(sio_uart_, STM32ZERO_SIO_UART, STM32ZERO_SIO_TX_SIZE, STM32ZERO_SIO_RX_SIZE, STM32ZERO_SIO_DMA_SIZE);

static bool initialized_ = false;

//=============================================================================
// Public API
//=============================================================================

namespace stm32zero {
namespace sio {

void init()
{
	if (initialized_) {
		return;
	}
	initialized_ = true;

	STM32ZERO_INIT_UART(sio_uart_, STM32ZERO_SIO_UART);
}

//-----------------------------------------------------------------------------
// Write (TX)
//-----------------------------------------------------------------------------

IoResult write(const void* data, size_t len)
{
	return sio_uart_.write(data, len);
}

int vwritef(char* buf, size_t size, const char* fmt, va_list args)
{
	return sio_uart_.vwritef(buf, size, fmt, args);
}

int writef(char* buf, size_t size, const char* fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	int len = vwritef(buf, size, fmt, args);
	va_end(args);
	return len;
}

IoResult writable()
{
	return sio_uart_.writable();
}

IoResult wait_writable(uint32_t timeout_ms)
{
	return sio_uart_.wait_writable(timeout_ms);
}

IoResult flush(uint32_t timeout_ms)
{
	return sio_uart_.flush(timeout_ms);
}

uint16_t write_peak()
{
	return sio_uart_.write_peak();
}

//-----------------------------------------------------------------------------
// Read (RX)
//-----------------------------------------------------------------------------

IoResult read(void* data, size_t len)
{
	return sio_uart_.read(data, len);
}

IoResult read(void* data, size_t len, uint32_t timeout_ms)
{
	return sio_uart_.read(data, len, timeout_ms);
}

IoResult readln(char* buf, size_t len, uint32_t timeout_ms)
{
	return sio_uart_.readln(buf, len, timeout_ms);
}

IoResult readable()
{
	return sio_uart_.readable();
}

IoResult wait_readable(uint32_t timeout_ms)
{
	return sio_uart_.wait_readable(timeout_ms);
}

void purge()
{
	sio_uart_.purge();
}

uint16_t read_peak()
{
	return sio_uart_.read_peak();
}

} // namespace sio
} // namespace stm32zero

//=============================================================================
// printf/scanf support (enabled by default)
//=============================================================================

#if !defined(STM32ZERO_SIO_NO_STDIO)

extern "C" int _write(int file, char* ptr, int len)
{
	(void)file;
	stm32zero::sio::IoResult result = stm32zero::sio::write(ptr, static_cast<size_t>(len));
	return result.count;
}

extern "C" int _read(int file, char* ptr, int len)
{
	(void)file;

	// Block until at least 1 byte is available
#if defined(STM32ZERO_RTOS_FREERTOS) && (STM32ZERO_RTOS_FREERTOS == 1)
	while (!stm32zero::sio::readable()) {
		stm32zero::sio::wait_readable(portMAX_DELAY);
	}
#else
	stm32zero::wait_until([]{ return stm32zero::sio::readable().is_ok(); }, UINT32_MAX);
#endif
	stm32zero::sio::IoResult result = stm32zero::sio::read(ptr, static_cast<size_t>(len));
	return result.count;
}

#endif // !STM32ZERO_SIO_NO_STDIO
