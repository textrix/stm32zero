/**
 * STM32ZERO Serial I/O Module Implementation
 */

#include "main.h"
#include "stm32zero-sio.hpp"
#include "stm32zero-serial.hpp"

//=============================================================================
// Configuration
//=============================================================================

#if __has_include("stm32zero-conf.h")
#include "stm32zero-conf.h"
#endif

#ifndef STM32ZERO_SIO_UART
#error "STM32ZERO_SIO_UART must be defined in stm32zero-conf.h"
#endif

#ifndef STM32ZERO_SIO_RX_SIZE
#define STM32ZERO_SIO_RX_SIZE		256
#endif

#ifndef STM32ZERO_SIO_TX_SIZE
#define STM32ZERO_SIO_TX_SIZE		4096
#endif

#ifndef STM32ZERO_SIO_DMA_SIZE
#define STM32ZERO_SIO_DMA_SIZE		64
#endif

// UART handle declaration (generated by STM32CubeMX)
extern UART_HandleTypeDef STM32ZERO_SIO_UART;

//=============================================================================
// Serial instance
//=============================================================================

DEFINE_SERIAL(sio_serial_, STM32ZERO_SIO_UART, STM32ZERO_SIO_RX_SIZE, STM32ZERO_SIO_TX_SIZE, STM32ZERO_SIO_DMA_SIZE);

static bool initialized_ = false;

//=============================================================================
// Public API
//=============================================================================

namespace stm32zero {
namespace sio {

void init()
{
	if (initialized_) {
		return;
	}
	initialized_ = true;

	INIT_SERIAL(sio_serial_, STM32ZERO_SIO_UART, STM32ZERO_SIO_DMA_SIZE);
}

//-----------------------------------------------------------------------------
// Write (TX)
//-----------------------------------------------------------------------------

int write(const void* data, size_t len)
{
	return sio_serial_.write(data, len);
}

bool flush()
{
	return sio_serial_.flush();
}

bool is_tx_busy()
{
	return sio_serial_.is_tx_busy();
}

uint16_t tx_pending()
{
	return sio_serial_.pending();
}

uint16_t tx_water_mark()
{
	return sio_serial_.tx_water_mark();
}

//-----------------------------------------------------------------------------
// Read (RX)
//-----------------------------------------------------------------------------

int read(void* data, size_t len)
{
	return sio_serial_.read(data, len);
}

int readln(char* buf, size_t len, uint32_t timeout_ms)
{
	return sio_serial_.readln(buf, len, timeout_ms);
}

bool wait(uint32_t timeout_ms)
{
	return sio_serial_.wait(timeout_ms);
}

size_t available()
{
	return sio_serial_.available();
}

bool is_empty()
{
	return sio_serial_.is_empty();
}

uint16_t rx_water_mark()
{
	return sio_serial_.rx_water_mark();
}

#if defined(STM32ZERO_RTOS_FREERTOS) && (STM32ZERO_RTOS_FREERTOS == 1)
SemaphoreHandle_t semaphore()
{
	return sio_serial_.semaphore();
}
#endif

} // namespace sio
} // namespace stm32zero

//=============================================================================
// newlib hooks for printf()/scanf()
//=============================================================================

extern "C" int _write(int file, char* ptr, int len)
{
	(void)file;
	return stm32zero::sio::write(ptr, len);
}

extern "C" int _read(int file, char* ptr, int len)
{
	(void)file;
	stm32zero::sio::wait(UINT32_MAX);
	return stm32zero::sio::read(ptr, len);
}
