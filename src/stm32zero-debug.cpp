/**
 * STM32ZERO Debug Module - DMA-based printf output
 *
 * Configuration (stm32zero-conf.h):
 *   - STM32ZERO_DEBUG_UART: UART handle name (required)
 *   - STM32ZERO_DEBUG_BUFFER_SIZE: Buffer size (default: 4096)
 *   - STM32ZERO_DEBUG_CACHE_CLEAN: Enable cache clean (default: 0)
 */

#include "main.h"
#include "stm32zero.hpp"
#include "stm32zero-debug.hpp"
#include <cstring>

//=============================================================================
// Configuration
//=============================================================================

#if __has_include("stm32zero-conf.h")
#include "stm32zero-conf.h"
#endif

#ifndef STM32ZERO_DEBUG_UART
#error "STM32ZERO_DEBUG_UART must be defined in stm32zero-conf.h"
#endif

#ifndef STM32ZERO_DEBUG_BUFFER_SIZE
#define STM32ZERO_DEBUG_BUFFER_SIZE	4096
#endif

#ifndef STM32ZERO_DEBUG_CACHE_CLEAN
#define STM32ZERO_DEBUG_CACHE_CLEAN	0
#endif

// UART handle declaration (generated by STM32CubeMX)
extern UART_HandleTypeDef STM32ZERO_DEBUG_UART;

using namespace stm32zero;

//=============================================================================
// DualBuffer template class
//=============================================================================

namespace {

template<size_t Size>
class DualBuffer {
	static_assert(Size > 0, "Buffer size must be greater than 0");
	static_assert(Size <= 65535, "Buffer size must fit in uint16_t");

public:
	void set_buffers(volatile uint8_t* buf0, volatile uint8_t* buf1)
	{
		buffers_[0] = buf0;
		buffers_[1] = buf1;
	}

	int write(const void* data, size_t len)
	{
		if (data == nullptr || len == 0) {
			return 0;
		}

		int written = 0;

		enter_critical();

		uint8_t idx = fill_idx_;
		uint16_t pos = fill_pos_[idx];
		uint16_t available = Size - pos;

		uint16_t to_write = (len > available) ? available : static_cast<uint16_t>(len);

		if (to_write > 0) {
			std::memcpy(const_cast<uint8_t*>(&buffers_[idx][pos]),
				    data, to_write);

			fill_pos_[idx] = pos + to_write;
			written = to_write;

			if (fill_pos_water_mark_[idx] < fill_pos_[idx]) {
				fill_pos_water_mark_[idx] = fill_pos_[idx];
			}

			if (!tx_busy_) {
				start_dma_locked();
			}
		}

		exit_critical();

		return written;
	}

	void tx_complete_isr()
	{
		enter_critical_from_isr();

		tx_busy_ = false;

		if (fill_pos_[fill_idx_] > 0) {
			start_dma_locked();
		}

		exit_critical_from_isr();
	}

	bool flush()
	{
		bool started = false;

		enter_critical();

		if (!tx_busy_ && fill_pos_[fill_idx_] > 0) {
			started = start_dma_locked();
		}

		exit_critical();

		return started;
	}

	bool is_busy() const { return tx_busy_; }
	uint16_t pending() const { return fill_pos_[fill_idx_]; }

	uint16_t water_mark() const
	{
		uint16_t wm0 = fill_pos_water_mark_[0];
		uint16_t wm1 = fill_pos_water_mark_[1];
		return (wm0 > wm1) ? wm0 : wm1;
	}

	static constexpr size_t size() { return Size; }

	static constexpr size_t aligned_size()
	{
		if constexpr (cache_line_size > 0) {
			return align_up<cache_line_size>(Size);
		} else {
			return Size;
		}
	}

private:
	bool start_dma_locked()
	{
		uint8_t tx_idx = fill_idx_;
		uint16_t tx_len = fill_pos_[tx_idx];

		if (tx_len == 0) {
			return false;
		}

		fill_idx_ = 1 - tx_idx;
		fill_pos_[fill_idx_] = 0;

		tx_busy_ = true;

#if STM32ZERO_DEBUG_CACHE_CLEAN
		if constexpr (cache_line_size > 0) {
			SCB_CleanDCache_by_Addr(
				reinterpret_cast<uint32_t*>(
					const_cast<uint8_t*>(buffers_[tx_idx])),
				aligned_size());
		}
#endif

		HAL_UART_Transmit_DMA(&STM32ZERO_DEBUG_UART,
			const_cast<uint8_t*>(buffers_[tx_idx]), tx_len);

		return true;
	}

	void enter_critical()
	{
#if defined(configUSE_PREEMPTION) && (configUSE_PREEMPTION == 1)
		taskENTER_CRITICAL();
#else
		primask_ = __get_PRIMASK();
		__disable_irq();
#endif
	}

	void exit_critical()
	{
#if defined(configUSE_PREEMPTION) && (configUSE_PREEMPTION == 1)
		taskEXIT_CRITICAL();
#else
		__set_PRIMASK(primask_);
#endif
	}

	void enter_critical_from_isr()
	{
#if defined(configUSE_PREEMPTION) && (configUSE_PREEMPTION == 1)
		saved_interrupt_status_ = taskENTER_CRITICAL_FROM_ISR();
#else
		primask_ = __get_PRIMASK();
		__disable_irq();
#endif
	}

	void exit_critical_from_isr()
	{
#if defined(configUSE_PREEMPTION) && (configUSE_PREEMPTION == 1)
		taskEXIT_CRITICAL_FROM_ISR(saved_interrupt_status_);
#else
		__set_PRIMASK(primask_);
#endif
	}

	volatile uint8_t* buffers_[2] = {nullptr, nullptr};
	volatile uint16_t fill_pos_[2] = {0, 0};
	volatile uint8_t fill_idx_ = 0;
	volatile bool tx_busy_ = false;
	volatile uint16_t fill_pos_water_mark_[2] = {0, 0};

#if defined(configUSE_PREEMPTION) && (configUSE_PREEMPTION == 1)
	UBaseType_t saved_interrupt_status_ = 0;
#else
	uint32_t primask_ = 0;
#endif
};

} // anonymous namespace

//=============================================================================
// Buffer storage and instance
//=============================================================================

STM32ZERO_DMA_TX static DmaBuffer<STM32ZERO_DEBUG_BUFFER_SIZE> tx_buf0_;
STM32ZERO_DMA_TX static DmaBuffer<STM32ZERO_DEBUG_BUFFER_SIZE> tx_buf1_;

STM32ZERO_DTCM static DualBuffer<STM32ZERO_DEBUG_BUFFER_SIZE> dual_buffer_;

namespace {

struct BufferInit {
	BufferInit()
	{
		dual_buffer_.set_buffers(tx_buf0_.data(), tx_buf1_.data());
	}
} buffer_init_;

} // anonymous namespace

//=============================================================================
// UART TX Complete Callback
//=============================================================================

static void uart_tx_complete_callback(UART_HandleTypeDef* huart)
{
	(void)huart;
	dual_buffer_.tx_complete_isr();
}

//=============================================================================
// Public API
//=============================================================================

namespace stm32zero {
namespace debug {

void init()
{
	HAL_UART_RegisterCallback(&STM32ZERO_DEBUG_UART,
		HAL_UART_TX_COMPLETE_CB_ID,
		uart_tx_complete_callback);
}

void tx_complete_isr()
{
	dual_buffer_.tx_complete_isr();
}

int write(const void* data, size_t len)
{
	return dual_buffer_.write(data, len);
}

bool flush()
{
	return dual_buffer_.flush();
}

bool is_busy()
{
	return dual_buffer_.is_busy();
}

uint16_t pending()
{
	return dual_buffer_.pending();
}

uint16_t water_mark()
{
	return dual_buffer_.water_mark();
}

size_t buffer_size()
{
	return dual_buffer_.size();
}

} // namespace debug
} // namespace stm32zero

//=============================================================================
// newlib _write override for printf()
//=============================================================================

extern "C" int _write(int file, char* ptr, int len)
{
	(void)file;
	return stm32zero::debug::write(ptr, len);
}
