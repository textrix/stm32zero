/**
 * STM32ZERO Stdin Module - DMA-based UART RX with Idle Line Detection
 *
 * Configuration (stm32zero-conf.h):
 *   - STM32ZERO_STDIN_UART: UART handle name (required)
 *   - STM32ZERO_STDIN_BUFFER_SIZE: Ring buffer size (default: 256)
 *   - STM32ZERO_STDIN_DMA_SIZE: DMA buffer size (default: 64)
 */

#include "main.h"
#include "stm32zero.hpp"
#include "stm32zero-sin.hpp"
#include <cstring>

#if defined(STM32ZERO_RTOS_FREERTOS) && (STM32ZERO_RTOS_FREERTOS == 1)
#include "stm32zero-freertos.hpp"
using namespace stm32zero::freertos;
#endif

//=============================================================================
// Configuration
//=============================================================================

#if __has_include("stm32zero-conf.h")
#include "stm32zero-conf.h"
#endif

#ifndef STM32ZERO_STDIN_UART
#error "STM32ZERO_STDIN_UART must be defined in stm32zero-conf.h"
#endif

#ifndef STM32ZERO_STDIN_BUFFER_SIZE
#define STM32ZERO_STDIN_BUFFER_SIZE	256
#endif

#ifndef STM32ZERO_STDIN_DMA_SIZE
#define STM32ZERO_STDIN_DMA_SIZE	64
#endif

// UART handle declaration (generated by STM32CubeMX)
extern UART_HandleTypeDef STM32ZERO_STDIN_UART;

using namespace stm32zero;

//=============================================================================
// RingBuffer template class
//=============================================================================

namespace {

template<size_t Size>
class RingBuffer {
	static_assert(Size > 0, "Buffer size must be greater than 0");
	static_assert(Size <= 65535, "Buffer size must fit in uint16_t");

public:
	size_t push(const uint8_t* data, size_t len)
	{
		if (data == nullptr || len == 0) {
			return 0;
		}

		CriticalSection cs;

		size_t written = 0;
		while (written < len && !is_full_locked()) {
			buffer_[head_] = data[written++];
			head_ = (head_ + 1) % Size;
		}

		uint16_t used = used_locked();
		if (used > water_mark_) {
			water_mark_ = used;
		}

		return written;
	}

	size_t pop(uint8_t* data, size_t len)
	{
		if (data == nullptr || len == 0) {
			return 0;
		}

		CriticalSection cs;

		size_t read_count = 0;
		while (read_count < len && !is_empty_locked()) {
			data[read_count++] = buffer_[tail_];
			tail_ = (tail_ + 1) % Size;
		}

		return read_count;
	}

	size_t available() const
	{
		CriticalSection cs;
		return used_locked();
	}

	bool is_empty() const
	{
		CriticalSection cs;
		return is_empty_locked();
	}

	bool is_full() const
	{
		CriticalSection cs;
		return is_full_locked();
	}

	uint16_t water_mark() const
	{
		return water_mark_;
	}

	static constexpr size_t size() { return Size; }

	size_t pop_until(uint8_t* data, size_t max_len, uint8_t delimiter, bool* found)
	{
		if (data == nullptr || max_len == 0 || found == nullptr) {
			if (found) *found = false;
			return 0;
		}

		CriticalSection cs;

		size_t delim_pos = find_locked(delimiter);
		size_t avail = used_locked();

		*found = (delim_pos < avail);

		size_t to_read = *found ? (delim_pos + 1) : avail;
		if (to_read > max_len) {
			to_read = max_len;
			*found = false;  // buffer too small
		}

		return pop_locked(data, to_read);
	}

private:
	bool is_empty_locked() const
	{
		return head_ == tail_;
	}

	bool is_full_locked() const
	{
		return ((head_ + 1) % Size) == tail_;
	}

	uint16_t used_locked() const
	{
		if (head_ >= tail_) {
			return head_ - tail_;
		} else {
			return Size - tail_ + head_;
		}
	}

	size_t find_locked(uint8_t delimiter) const
	{
		uint16_t idx = tail_;
		size_t count = 0;
		while (idx != head_) {
			if (buffer_[idx] == delimiter) {
				return count;
			}
			idx = (idx + 1) % Size;
			count++;
		}
		return count;  // not found, return total size
	}

	size_t pop_locked(uint8_t* data, size_t len)
	{
		size_t read_count = 0;
		while (read_count < len && !is_empty_locked()) {
			data[read_count++] = buffer_[tail_];
			tail_ = (tail_ + 1) % Size;
		}
		return read_count;
	}

	uint8_t buffer_[Size];
	volatile uint16_t head_ = 0;
	volatile uint16_t tail_ = 0;
	volatile uint16_t water_mark_ = 0;
};

} // anonymous namespace

//=============================================================================
// Buffer storage
//=============================================================================

// DMA receive buffer (DMA accessible region)
STM32ZERO_DMA_RX static DmaBuffer<STM32ZERO_STDIN_DMA_SIZE> dma_buf_;

// Ring buffer (DTCM - fast access)
STM32ZERO_DTCM static RingBuffer<STM32ZERO_STDIN_BUFFER_SIZE> ring_buffer_;

#if defined(STM32ZERO_RTOS_FREERTOS) && (STM32ZERO_RTOS_FREERTOS == 1)
// Binary semaphore for blocking wait
STM32ZERO_DTCM static StaticBinarySemaphore rx_sem_;
#endif

//=============================================================================
// RxEvent Callback
//=============================================================================

static void rx_event_callback(UART_HandleTypeDef* huart, uint16_t size)
{
	(void)huart;

	// Copy received data to ring buffer
	ring_buffer_.push(const_cast<uint8_t*>(dma_buf_.data()), size);

#if defined(STM32ZERO_RTOS_FREERTOS) && (STM32ZERO_RTOS_FREERTOS == 1)
	// Signal waiting task
	rx_sem_.give_from_isr();
#endif

	// Restart DMA reception
	HAL_UARTEx_ReceiveToIdle_DMA(&STM32ZERO_STDIN_UART,
		const_cast<uint8_t*>(dma_buf_.data()),
		dma_buf_.size());
}

//=============================================================================
// Public API
//=============================================================================

namespace stm32zero {
namespace sin {

void init()
{
#if defined(STM32ZERO_RTOS_FREERTOS) && (STM32ZERO_RTOS_FREERTOS == 1)
	rx_sem_.create();
#endif
	HAL_UART_RegisterRxEventCallback(&STM32ZERO_STDIN_UART, rx_event_callback);
	HAL_UARTEx_ReceiveToIdle_DMA(&STM32ZERO_STDIN_UART,
		const_cast<uint8_t*>(dma_buf_.data()),
		dma_buf_.size());
}

int read(void* data, size_t len)
{
	return static_cast<int>(ring_buffer_.pop(static_cast<uint8_t*>(data), len));
}

size_t available()
{
	return ring_buffer_.available();
}

bool is_empty()
{
	return ring_buffer_.is_empty();
}

uint16_t water_mark()
{
	return ring_buffer_.water_mark();
}

size_t buffer_size()
{
	return ring_buffer_.size();
}

int readln(char* buf, size_t len, uint32_t timeout_ms)
{
	if (buf == nullptr || len == 0) {
		return -1;
	}

	size_t pos = 0;
	size_t max_chars = len - 1;  // Reserve space for null terminator

	while (pos < max_chars) {
		if (!wait(timeout_ms)) {
			// Timeout
			if (pos == 0) {
				buf[0] = '\0';
				return -1;
			}
			break;
		}

		bool found = false;
		size_t n = ring_buffer_.pop_until(
			reinterpret_cast<uint8_t*>(buf + pos),
			max_chars - pos,
			'\n',
			&found
		);

		pos += n;

		if (found) {
			// Strip trailing \n or \r
			while (pos > 0 && (buf[pos - 1] == '\n' || buf[pos - 1] == '\r')) {
				pos--;
			}
			break;
		}
	}

	buf[pos] = '\0';
	return static_cast<int>(pos);
}

bool wait(uint32_t timeout_ms)
{
	if (!ring_buffer_.is_empty()) {
		return true;
	}

#if defined(STM32ZERO_RTOS_FREERTOS) && (STM32ZERO_RTOS_FREERTOS == 1)
	return rx_sem_.take(pdMS_TO_TICKS(timeout_ms));
#else
	return wait_until([]{ return !ring_buffer_.is_empty(); }, timeout_ms);
#endif
}

#if defined(STM32ZERO_RTOS_FREERTOS) && (STM32ZERO_RTOS_FREERTOS == 1)
SemaphoreHandle_t semaphore()
{
	return rx_sem_.handle();
}
#endif

} // namespace sin
} // namespace stm32zero

//=============================================================================
// newlib _read override for scanf()
//=============================================================================

extern "C" int _read(int file, char* ptr, int len)
{
	(void)file;
	stm32zero::sin::wait(UINT32_MAX);
	return stm32zero::sin::read(ptr, len);
}
